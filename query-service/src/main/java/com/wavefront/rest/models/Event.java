/*
 * Wavefront REST API
 * <p>The Wavefront REST API enables you to interact with Wavefront servers using standard REST API tools. You can use the REST API to automate commonly executed operations such as automatically tagging sources.</p><p>When you make REST API calls outside the Wavefront REST API documentation you must add the header \"Authorization: Bearer &lt;&lt;API-TOKEN&gt;&gt;\" to your HTTP requests.</p>
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.wavefront.rest.models;

import java.util.Objects;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Wavefront Event
 */
@ApiModel(description = "Wavefront Event")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-02-25T16:34:08.557+05:30")
public class Event {
  @SerializedName("startTime")
  private Long startTime = null;

  @SerializedName("table")
  private String table = null;

  @SerializedName("endTime")
  private Long endTime = null;

  @SerializedName("tags")
  private List<String> tags = null;

  @SerializedName("annotations")
  private Map<String, String> annotations = new HashMap<String, String>();

  @SerializedName("createdAt")
  private Long createdAt = null;

  @SerializedName("isUserEvent")
  private Boolean isUserEvent = null;

  @SerializedName("summarizedEvents")
  private Long summarizedEvents = null;

  @SerializedName("hosts")
  private List<String> hosts = null;

  @SerializedName("isEphemeral")
  private Boolean isEphemeral = null;

  @SerializedName("creatorId")
  private String creatorId = null;

  @SerializedName("updaterId")
  private String updaterId = null;

  @SerializedName("updatedAt")
  private Long updatedAt = null;

  @SerializedName("id")
  private String id = null;

  @SerializedName("createdEpochMillis")
  private Long createdEpochMillis = null;

  @SerializedName("updatedEpochMillis")
  private Long updatedEpochMillis = null;

  @SerializedName("canDelete")
  private Boolean canDelete = null;

  @SerializedName("canClose")
  private Boolean canClose = null;

  /**
   * Gets or Sets creatorType
   */
  @JsonAdapter(CreatorTypeEnum.Adapter.class)
  public enum CreatorTypeEnum {
    USER("USER"),

    ALERT("ALERT"),

    SYSTEM("SYSTEM");

    private String value;

    CreatorTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CreatorTypeEnum fromValue(String text) {
      for (CreatorTypeEnum b : CreatorTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<CreatorTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CreatorTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CreatorTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CreatorTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("creatorType")
  private List<CreatorTypeEnum> creatorType = null;

  /**
   * Gets or Sets runningState
   */
  @JsonAdapter(RunningStateEnum.Adapter.class)
  public enum RunningStateEnum {
    ONGOING("ONGOING"),

    PENDING("PENDING"),

    ENDED("ENDED");

    private String value;

    RunningStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RunningStateEnum fromValue(String text) {
      for (RunningStateEnum b : RunningStateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<RunningStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RunningStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RunningStateEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return RunningStateEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("runningState")
  private RunningStateEnum runningState = null;

  @SerializedName("name")
  private String name = null;

  public Event startTime(Long startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Start time of the event, in epoch millis.  If the JSON value is missing or set to 0, startTime will be set to the current time
   *
   * @return startTime
   **/
  @ApiModelProperty(required = true, value = "Start time of the event, in epoch millis.  If the JSON value is missing or set to 0, startTime will be set to the current time")
  public Long getStartTime() {
    return startTime;
  }

  public void setStartTime(Long startTime) {
    this.startTime = startTime;
  }

  /**
   * The customer to which the event belongs
   *
   * @return table
   **/
  @ApiModelProperty(value = "The customer to which the event belongs")
  public String getTable() {
    return table;
  }

  public Event endTime(Long endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * End time of the event, in epoch millis.  Set to startTime + 1 for an instantaneous event
   *
   * @return endTime
   **/
  @ApiModelProperty(value = "End time of the event, in epoch millis.  Set to startTime + 1 for an instantaneous event")
  public Long getEndTime() {
    return endTime;
  }

  public void setEndTime(Long endTime) {
    this.endTime = endTime;
  }

  public Event tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public Event addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<String>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * A list of event tags
   *
   * @return tags
   **/
  @ApiModelProperty(value = "A list of event tags")
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }

  public Event annotations(Map<String, String> annotations) {
    this.annotations = annotations;
    return this;
  }

  public Event putAnnotationsItem(String key, String annotationsItem) {
    this.annotations.put(key, annotationsItem);
    return this;
  }

  /**
   * A string-&gt;string map of additional annotations on the event
   *
   * @return annotations
   **/
  @ApiModelProperty(required = true, value = "A string->string map of additional annotations on the event")
  public Map<String, String> getAnnotations() {
    return annotations;
  }

  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }

  /**
   * Get createdAt
   *
   * @return createdAt
   **/
  @ApiModelProperty(value = "")
  public Long getCreatedAt() {
    return createdAt;
  }

  /**
   * Whether this event was created by a user, versus the system.  Default: system
   *
   * @return isUserEvent
   **/
  @ApiModelProperty(value = "Whether this event was created by a user, versus the system.  Default: system")
  public Boolean isIsUserEvent() {
    return isUserEvent;
  }

  /**
   * In some event queries, multiple events that occur nearly simultaneously are summarized under a single event.  This value specifies the number of events summarized under this one
   *
   * @return summarizedEvents
   **/
  @ApiModelProperty(value = "In some event queries, multiple events that occur nearly simultaneously are summarized under a single event.  This value specifies the number of events summarized under this one")
  public Long getSummarizedEvents() {
    return summarizedEvents;
  }

  public Event hosts(List<String> hosts) {
    this.hosts = hosts;
    return this;
  }

  public Event addHostsItem(String hostsItem) {
    if (this.hosts == null) {
      this.hosts = new ArrayList<String>();
    }
    this.hosts.add(hostsItem);
    return this;
  }

  /**
   * A list of sources/hosts affected by the event
   *
   * @return hosts
   **/
  @ApiModelProperty(value = "A list of sources/hosts affected by the event")
  public List<String> getHosts() {
    return hosts;
  }

  public void setHosts(List<String> hosts) {
    this.hosts = hosts;
  }

  /**
   * Whether the event is an artificial event generated by a literal expression or alert backtesting, i.e. not stored in the Wavefront backend
   *
   * @return isEphemeral
   **/
  @ApiModelProperty(value = "Whether the event is an artificial event generated by a literal expression or alert backtesting, i.e. not stored in the Wavefront backend")
  public Boolean isIsEphemeral() {
    return isEphemeral;
  }

  /**
   * Get creatorId
   *
   * @return creatorId
   **/
  @ApiModelProperty(value = "")
  public String getCreatorId() {
    return creatorId;
  }

  /**
   * Get updaterId
   *
   * @return updaterId
   **/
  @ApiModelProperty(value = "")
  public String getUpdaterId() {
    return updaterId;
  }

  /**
   * Get updatedAt
   *
   * @return updatedAt
   **/
  @ApiModelProperty(value = "")
  public Long getUpdatedAt() {
    return updatedAt;
  }

  public Event id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   *
   * @return id
   **/
  @ApiModelProperty(value = "")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  /**
   * Get createdEpochMillis
   *
   * @return createdEpochMillis
   **/
  @ApiModelProperty(value = "")
  public Long getCreatedEpochMillis() {
    return createdEpochMillis;
  }

  /**
   * Get updatedEpochMillis
   *
   * @return updatedEpochMillis
   **/
  @ApiModelProperty(value = "")
  public Long getUpdatedEpochMillis() {
    return updatedEpochMillis;
  }

  /**
   * Get canDelete
   *
   * @return canDelete
   **/
  @ApiModelProperty(value = "")
  public Boolean isCanDelete() {
    return canDelete;
  }

  /**
   * Get canClose
   *
   * @return canClose
   **/
  @ApiModelProperty(value = "")
  public Boolean isCanClose() {
    return canClose;
  }

  public Event creatorType(List<CreatorTypeEnum> creatorType) {
    this.creatorType = creatorType;
    return this;
  }

  public Event addCreatorTypeItem(CreatorTypeEnum creatorTypeItem) {
    if (this.creatorType == null) {
      this.creatorType = new ArrayList<CreatorTypeEnum>();
    }
    this.creatorType.add(creatorTypeItem);
    return this;
  }

  /**
   * Get creatorType
   *
   * @return creatorType
   **/
  @ApiModelProperty(value = "")
  public List<CreatorTypeEnum> getCreatorType() {
    return creatorType;
  }

  public void setCreatorType(List<CreatorTypeEnum> creatorType) {
    this.creatorType = creatorType;
  }

  /**
   * Get runningState
   *
   * @return runningState
   **/
  @ApiModelProperty(value = "")
  public RunningStateEnum getRunningState() {
    return runningState;
  }

  public Event name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the event.  If &#39;annotations.prettyName&#39; is present, &#39;name&#39; will be equivalent to that value
   *
   * @return name
   **/
  @ApiModelProperty(required = true, value = "The name of the event.  If 'annotations.prettyName' is present, 'name' will be equivalent to that value")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Event event = (Event) o;
    return Objects.equals(this.startTime, event.startTime) &&
        Objects.equals(this.table, event.table) &&
        Objects.equals(this.endTime, event.endTime) &&
        Objects.equals(this.tags, event.tags) &&
        Objects.equals(this.annotations, event.annotations) &&
        Objects.equals(this.createdAt, event.createdAt) &&
        Objects.equals(this.isUserEvent, event.isUserEvent) &&
        Objects.equals(this.summarizedEvents, event.summarizedEvents) &&
        Objects.equals(this.hosts, event.hosts) &&
        Objects.equals(this.isEphemeral, event.isEphemeral) &&
        Objects.equals(this.creatorId, event.creatorId) &&
        Objects.equals(this.updaterId, event.updaterId) &&
        Objects.equals(this.updatedAt, event.updatedAt) &&
        Objects.equals(this.id, event.id) &&
        Objects.equals(this.createdEpochMillis, event.createdEpochMillis) &&
        Objects.equals(this.updatedEpochMillis, event.updatedEpochMillis) &&
        Objects.equals(this.canDelete, event.canDelete) &&
        Objects.equals(this.canClose, event.canClose) &&
        Objects.equals(this.creatorType, event.creatorType) &&
        Objects.equals(this.runningState, event.runningState) &&
        Objects.equals(this.name, event.name);
  }

  @Override
  public int hashCode() {
    return Objects.hash(startTime, table, endTime, tags, annotations, createdAt, isUserEvent, summarizedEvents, hosts, isEphemeral, creatorId, updaterId, updatedAt, id, createdEpochMillis, updatedEpochMillis, canDelete, canClose, creatorType, runningState, name);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Event {\n");

    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    table: ").append(toIndentedString(table)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    isUserEvent: ").append(toIndentedString(isUserEvent)).append("\n");
    sb.append("    summarizedEvents: ").append(toIndentedString(summarizedEvents)).append("\n");
    sb.append("    hosts: ").append(toIndentedString(hosts)).append("\n");
    sb.append("    isEphemeral: ").append(toIndentedString(isEphemeral)).append("\n");
    sb.append("    creatorId: ").append(toIndentedString(creatorId)).append("\n");
    sb.append("    updaterId: ").append(toIndentedString(updaterId)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    createdEpochMillis: ").append(toIndentedString(createdEpochMillis)).append("\n");
    sb.append("    updatedEpochMillis: ").append(toIndentedString(updatedEpochMillis)).append("\n");
    sb.append("    canDelete: ").append(toIndentedString(canDelete)).append("\n");
    sb.append("    canClose: ").append(toIndentedString(canClose)).append("\n");
    sb.append("    creatorType: ").append(toIndentedString(creatorType)).append("\n");
    sb.append("    runningState: ").append(toIndentedString(runningState)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

