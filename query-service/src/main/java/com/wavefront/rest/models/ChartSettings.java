/*
 * Wavefront REST API
 * <p>The Wavefront REST API enables you to interact with Wavefront servers using standard REST API tools. You can use the REST API to automate commonly executed operations such as automatically tagging sources.</p><p>When you make REST API calls outside the Wavefront REST API documentation you must add the header \"Authorization: Bearer &lt;&lt;API-TOKEN&gt;&gt;\" to your HTTP requests.</p>
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.wavefront.rest.models;

import java.util.Objects;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Representation of the settings of a Wavefront chart
 */
@ApiModel(description = "Representation of the settings of a Wavefront chart")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-02-25T16:34:08.557+05:30")
public class ChartSettings {
  /**
   * Chart Type.  &#39;line&#39; refers to the Line Plot, &#39;scatter&#39; to the Point Plot, &#39;stacked-area&#39; to the Stacked Area plot, &#39;table&#39; to the Tabular View, &#39;scatterploy-xy&#39; to Scatter Plot, &#39;markdown-widget&#39; to the Markdown display, and &#39;sparkline&#39; to the Single Stat view
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    LINE("line"),

    SCATTERPLOT("scatterplot"),

    STACKED_AREA("stacked-area"),

    TABLE("table"),

    SCATTERPLOT_XY("scatterplot-xy"),

    MARKDOWN_WIDGET("markdown-widget"),

    SPARKLINE("sparkline");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("min")
  private Double min = null;

  @SerializedName("sparklineDisplayColor")
  private String sparklineDisplayColor = null;

  @SerializedName("sparklineDisplayVerticalPosition")
  private String sparklineDisplayVerticalPosition = null;

  /**
   * For the single stat view, the horizontal position of the displayed text
   */
  @JsonAdapter(SparklineDisplayHorizontalPositionEnum.Adapter.class)
  public enum SparklineDisplayHorizontalPositionEnum {
    MIDDLE("MIDDLE"),

    LEFT("LEFT"),

    RIGHT("RIGHT");

    private String value;

    SparklineDisplayHorizontalPositionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SparklineDisplayHorizontalPositionEnum fromValue(String text) {
      for (SparklineDisplayHorizontalPositionEnum b : SparklineDisplayHorizontalPositionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SparklineDisplayHorizontalPositionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SparklineDisplayHorizontalPositionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SparklineDisplayHorizontalPositionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SparklineDisplayHorizontalPositionEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("sparklineDisplayHorizontalPosition")
  private SparklineDisplayHorizontalPositionEnum sparklineDisplayHorizontalPosition = null;

  @SerializedName("sparklineDisplayFontSize")
  private String sparklineDisplayFontSize = null;

  /**
   * Plot interpolation type.  linear is default
   */
  @JsonAdapter(LineTypeEnum.Adapter.class)
  public enum LineTypeEnum {
    LINEAR("linear"),

    STEP_BEFORE("step-before"),

    STEP_AFTER("step-after"),

    BASIS("basis"),

    CARDINAL("cardinal"),

    MONOTONE("monotone");

    private String value;

    LineTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LineTypeEnum fromValue(String text) {
      for (LineTypeEnum b : LineTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<LineTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LineTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LineTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LineTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("lineType")
  private LineTypeEnum lineType = null;

  /**
   * Type of stacked chart (applicable only if chart type is stacked).  zero (default) means stacked from y&#x3D;0.  expand means Normalized from 0 to 1.  wiggle means Minimize weighted changes. silhouette means to Center the Stream
   */
  @JsonAdapter(StackTypeEnum.Adapter.class)
  public enum StackTypeEnum {
    ZERO("zero"),

    EXPAND("expand"),

    WIGGLE("wiggle"),

    SILHOUETTE("silhouette");

    private String value;

    StackTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StackTypeEnum fromValue(String text) {
      for (StackTypeEnum b : StackTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<StackTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StackTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StackTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StackTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("stackType")
  private StackTypeEnum stackType = null;

  /**
   * For the tabular view, whether to use the full time window for the query or the last X minutes
   */
  @JsonAdapter(WindowingEnum.Adapter.class)
  public enum WindowingEnum {
    FULL("full"),

    LAST("last");

    private String value;

    WindowingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static WindowingEnum fromValue(String text) {
      for (WindowingEnum b : WindowingEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<WindowingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WindowingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WindowingEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return WindowingEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("windowing")
  private WindowingEnum windowing = null;

  @SerializedName("windowSize")
  private Long windowSize = null;

  @SerializedName("showHosts")
  private Boolean showHosts = null;

  @SerializedName("showLabels")
  private Boolean showLabels = null;

  @SerializedName("showRawValues")
  private Boolean showRawValues = null;

  @SerializedName("autoColumnTags")
  private Boolean autoColumnTags = null;

  @SerializedName("columnTags")
  private String columnTags = null;

  /**
   * For the tabular view, which mode to use to determine which point tags to display
   */
  @JsonAdapter(TagModeEnum.Adapter.class)
  public enum TagModeEnum {
    ALL("all"),

    TOP("top"),

    CUSTOM("custom");

    private String value;

    TagModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TagModeEnum fromValue(String text) {
      for (TagModeEnum b : TagModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TagModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TagModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TagModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TagModeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("tagMode")
  private TagModeEnum tagMode = null;

  @SerializedName("numTags")
  private Integer numTags = null;

  @SerializedName("customTags")
  private List<String> customTags = null;

  @SerializedName("groupBySource")
  private Boolean groupBySource = null;

  @SerializedName("sortValuesDescending")
  private Boolean sortValuesDescending = null;

  @SerializedName("y1Max")
  private Double y1Max = null;

  /**
   * Where the fixed legend should be displayed with respect to the chart
   */
  @JsonAdapter(FixedLegendPositionEnum.Adapter.class)
  public enum FixedLegendPositionEnum {
    RIGHT("RIGHT"),

    TOP("TOP"),

    LEFT("LEFT"),

    BOTTOM("BOTTOM");

    private String value;

    FixedLegendPositionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FixedLegendPositionEnum fromValue(String text) {
      for (FixedLegendPositionEnum b : FixedLegendPositionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<FixedLegendPositionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FixedLegendPositionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FixedLegendPositionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return FixedLegendPositionEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("fixedLegendPosition")
  private FixedLegendPositionEnum fixedLegendPosition = null;

  @SerializedName("fixedLegendDisplayStats")
  private List<String> fixedLegendDisplayStats = null;

  /**
   * Whether to display \&quot;Top\&quot;- or \&quot;Bottom\&quot;-ranked series in the fixed legend
   */
  @JsonAdapter(FixedLegendFilterSortEnum.Adapter.class)
  public enum FixedLegendFilterSortEnum {
    TOP("TOP"),

    BOTTOM("BOTTOM");

    private String value;

    FixedLegendFilterSortEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FixedLegendFilterSortEnum fromValue(String text) {
      for (FixedLegendFilterSortEnum b : FixedLegendFilterSortEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<FixedLegendFilterSortEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FixedLegendFilterSortEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FixedLegendFilterSortEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return FixedLegendFilterSortEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("fixedLegendFilterSort")
  private FixedLegendFilterSortEnum fixedLegendFilterSort = null;

  @SerializedName("fixedLegendFilterLimit")
  private Integer fixedLegendFilterLimit = null;

  @SerializedName("ymax")
  private Double ymax = null;

  @SerializedName("ymin")
  private Double ymin = null;

  @SerializedName("timeBasedColoring")
  private Boolean timeBasedColoring = null;

  /**
   * For the single stat view, whether to display the name of the query or the value of query
   */
  @JsonAdapter(SparklineDisplayValueTypeEnum.Adapter.class)
  public enum SparklineDisplayValueTypeEnum {
    VALUE("VALUE"),

    LABEL("LABEL");

    private String value;

    SparklineDisplayValueTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SparklineDisplayValueTypeEnum fromValue(String text) {
      for (SparklineDisplayValueTypeEnum b : SparklineDisplayValueTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SparklineDisplayValueTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SparklineDisplayValueTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SparklineDisplayValueTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SparklineDisplayValueTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("sparklineDisplayValueType")
  private SparklineDisplayValueTypeEnum sparklineDisplayValueType = null;

  /**
   * Statistic to use for determining whether a series is displayed on the fixed legend
   */
  @JsonAdapter(FixedLegendFilterFieldEnum.Adapter.class)
  public enum FixedLegendFilterFieldEnum {
    CURRENT("CURRENT"),

    MEAN("MEAN"),

    MEDIAN("MEDIAN"),

    SUM("SUM"),

    MIN("MIN"),

    MAX("MAX"),

    COUNT("COUNT");

    private String value;

    FixedLegendFilterFieldEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FixedLegendFilterFieldEnum fromValue(String text) {
      for (FixedLegendFilterFieldEnum b : FixedLegendFilterFieldEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<FixedLegendFilterFieldEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FixedLegendFilterFieldEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FixedLegendFilterFieldEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return FixedLegendFilterFieldEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("fixedLegendFilterField")
  private FixedLegendFilterFieldEnum fixedLegendFilterField = null;

  @SerializedName("fixedLegendHideLabel")
  private Boolean fixedLegendHideLabel = null;

  @SerializedName("xmax")
  private Double xmax = null;

  @SerializedName("xmin")
  private Double xmin = null;

  @SerializedName("y1UnitAutoscaling")
  private Boolean y1UnitAutoscaling = null;

  @SerializedName("invertDynamicLegendHoverControl")
  private Boolean invertDynamicLegendHoverControl = null;

  @SerializedName("fixedLegendEnabled")
  private Boolean fixedLegendEnabled = null;

  @SerializedName("fixedLegendUseRawStats")
  private Boolean fixedLegendUseRawStats = null;

  @SerializedName("sparklineDisplayPrefix")
  private String sparklineDisplayPrefix = null;

  @SerializedName("sparklineDisplayPostfix")
  private String sparklineDisplayPostfix = null;

  /**
   * For the single stat view, a misleadingly named property.  This determines whether the sparkline of the statistic is displayed in the chart BACKGROUND, BOTTOM, or NONE
   */
  @JsonAdapter(SparklineSizeEnum.Adapter.class)
  public enum SparklineSizeEnum {
    BACKGROUND("BACKGROUND"),

    BOTTOM("BOTTOM"),

    NONE("NONE");

    private String value;

    SparklineSizeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SparklineSizeEnum fromValue(String text) {
      for (SparklineSizeEnum b : SparklineSizeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SparklineSizeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SparklineSizeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SparklineSizeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SparklineSizeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("sparklineSize")
  private SparklineSizeEnum sparklineSize = null;

  @SerializedName("sparklineLineColor")
  private String sparklineLineColor = null;

  @SerializedName("sparklineDecimalPrecision")
  private Integer sparklineDecimalPrecision = null;

  @SerializedName("sparklineValueTextMapText")
  private List<String> sparklineValueTextMapText = null;

  @SerializedName("sparklineValueTextMapThresholds")
  private List<Float> sparklineValueTextMapThresholds = null;

  @SerializedName("sparklineFillColor")
  private String sparklineFillColor = null;

  @SerializedName("sparklineValueColorMapColors")
  private List<String> sparklineValueColorMapColors = null;

  @SerializedName("sparklineValueColorMapValuesV2")
  private List<Float> sparklineValueColorMapValuesV2 = null;

  @SerializedName("y1Min")
  private Double y1Min = null;

  @SerializedName("y1Units")
  private String y1Units = null;

  @SerializedName("y0ScaleSIBy1024")
  private Boolean y0ScaleSIBy1024 = null;

  @SerializedName("y1ScaleSIBy1024")
  private Boolean y1ScaleSIBy1024 = null;

  @SerializedName("y0UnitAutoscaling")
  private Boolean y0UnitAutoscaling = null;

  @SerializedName("sparklineValueColorMapValues")
  private List<Long> sparklineValueColorMapValues = null;

  /**
   * For the single stat view, whether to apply dynamic color settings to the displayed TEXT or BACKGROUND
   */
  @JsonAdapter(SparklineValueColorMapApplyToEnum.Adapter.class)
  public enum SparklineValueColorMapApplyToEnum {
    TEXT("TEXT"),

    BACKGROUND("BACKGROUND");

    private String value;

    SparklineValueColorMapApplyToEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SparklineValueColorMapApplyToEnum fromValue(String text) {
      for (SparklineValueColorMapApplyToEnum b : SparklineValueColorMapApplyToEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SparklineValueColorMapApplyToEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SparklineValueColorMapApplyToEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SparklineValueColorMapApplyToEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SparklineValueColorMapApplyToEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("sparklineValueColorMapApplyTo")
  private SparklineValueColorMapApplyToEnum sparklineValueColorMapApplyTo = null;

  @SerializedName("max")
  private Double max = null;

  @SerializedName("expectedDataSpacing")
  private Long expectedDataSpacing = null;

  @SerializedName("plainMarkdownContent")
  private String plainMarkdownContent = null;

  public ChartSettings type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Chart Type.  &#39;line&#39; refers to the Line Plot, &#39;scatter&#39; to the Point Plot, &#39;stacked-area&#39; to the Stacked Area plot, &#39;table&#39; to the Tabular View, &#39;scatterploy-xy&#39; to Scatter Plot, &#39;markdown-widget&#39; to the Markdown display, and &#39;sparkline&#39; to the Single Stat view
   *
   * @return type
   **/
  @ApiModelProperty(required = true, value = "Chart Type.  'line' refers to the Line Plot, 'scatter' to the Point Plot, 'stacked-area' to the Stacked Area plot, 'table' to the Tabular View, 'scatterploy-xy' to Scatter Plot, 'markdown-widget' to the Markdown display, and 'sparkline' to the Single Stat view")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public ChartSettings min(Double min) {
    this.min = min;
    return this;
  }

  /**
   * Min value of Y-axis.  Set to null or leave blank for auto
   *
   * @return min
   **/
  @ApiModelProperty(value = "Min value of Y-axis.  Set to null or leave blank for auto")
  public Double getMin() {
    return min;
  }

  public void setMin(Double min) {
    this.min = min;
  }

  public ChartSettings sparklineDisplayColor(String sparklineDisplayColor) {
    this.sparklineDisplayColor = sparklineDisplayColor;
    return this;
  }

  /**
   * For the single stat view, the color of the displayed text (when not dynamically determined). Values should be in\&quot;rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;\&quot; format
   *
   * @return sparklineDisplayColor
   **/
  @ApiModelProperty(value = "For the single stat view, the color of the displayed text (when not dynamically determined). Values should be in\"rgba(<rval>, <gval>, <bval>, <aval>\" format")
  public String getSparklineDisplayColor() {
    return sparklineDisplayColor;
  }

  public void setSparklineDisplayColor(String sparklineDisplayColor) {
    this.sparklineDisplayColor = sparklineDisplayColor;
  }

  public ChartSettings sparklineDisplayVerticalPosition(String sparklineDisplayVerticalPosition) {
    this.sparklineDisplayVerticalPosition = sparklineDisplayVerticalPosition;
    return this;
  }

  /**
   * deprecated
   *
   * @return sparklineDisplayVerticalPosition
   **/
  @ApiModelProperty(value = "deprecated")
  public String getSparklineDisplayVerticalPosition() {
    return sparklineDisplayVerticalPosition;
  }

  public void setSparklineDisplayVerticalPosition(String sparklineDisplayVerticalPosition) {
    this.sparklineDisplayVerticalPosition = sparklineDisplayVerticalPosition;
  }

  public ChartSettings sparklineDisplayHorizontalPosition(SparklineDisplayHorizontalPositionEnum sparklineDisplayHorizontalPosition) {
    this.sparklineDisplayHorizontalPosition = sparklineDisplayHorizontalPosition;
    return this;
  }

  /**
   * For the single stat view, the horizontal position of the displayed text
   *
   * @return sparklineDisplayHorizontalPosition
   **/
  @ApiModelProperty(value = "For the single stat view, the horizontal position of the displayed text")
  public SparklineDisplayHorizontalPositionEnum getSparklineDisplayHorizontalPosition() {
    return sparklineDisplayHorizontalPosition;
  }

  public void setSparklineDisplayHorizontalPosition(SparklineDisplayHorizontalPositionEnum sparklineDisplayHorizontalPosition) {
    this.sparklineDisplayHorizontalPosition = sparklineDisplayHorizontalPosition;
  }

  public ChartSettings sparklineDisplayFontSize(String sparklineDisplayFontSize) {
    this.sparklineDisplayFontSize = sparklineDisplayFontSize;
    return this;
  }

  /**
   * For the single stat view, the font size of the displayed text, in percent
   *
   * @return sparklineDisplayFontSize
   **/
  @ApiModelProperty(value = "For the single stat view, the font size of the displayed text, in percent")
  public String getSparklineDisplayFontSize() {
    return sparklineDisplayFontSize;
  }

  public void setSparklineDisplayFontSize(String sparklineDisplayFontSize) {
    this.sparklineDisplayFontSize = sparklineDisplayFontSize;
  }

  public ChartSettings lineType(LineTypeEnum lineType) {
    this.lineType = lineType;
    return this;
  }

  /**
   * Plot interpolation type.  linear is default
   *
   * @return lineType
   **/
  @ApiModelProperty(value = "Plot interpolation type.  linear is default")
  public LineTypeEnum getLineType() {
    return lineType;
  }

  public void setLineType(LineTypeEnum lineType) {
    this.lineType = lineType;
  }

  public ChartSettings stackType(StackTypeEnum stackType) {
    this.stackType = stackType;
    return this;
  }

  /**
   * Type of stacked chart (applicable only if chart type is stacked).  zero (default) means stacked from y&#x3D;0.  expand means Normalized from 0 to 1.  wiggle means Minimize weighted changes. silhouette means to Center the Stream
   *
   * @return stackType
   **/
  @ApiModelProperty(value = "Type of stacked chart (applicable only if chart type is stacked).  zero (default) means stacked from y=0.  expand means Normalized from 0 to 1.  wiggle means Minimize weighted changes. silhouette means to Center the Stream")
  public StackTypeEnum getStackType() {
    return stackType;
  }

  public void setStackType(StackTypeEnum stackType) {
    this.stackType = stackType;
  }

  public ChartSettings windowing(WindowingEnum windowing) {
    this.windowing = windowing;
    return this;
  }

  /**
   * For the tabular view, whether to use the full time window for the query or the last X minutes
   *
   * @return windowing
   **/
  @ApiModelProperty(value = "For the tabular view, whether to use the full time window for the query or the last X minutes")
  public WindowingEnum getWindowing() {
    return windowing;
  }

  public void setWindowing(WindowingEnum windowing) {
    this.windowing = windowing;
  }

  public ChartSettings windowSize(Long windowSize) {
    this.windowSize = windowSize;
    return this;
  }

  /**
   * Width, in minutes, of the time window to use for \&quot;last\&quot; windowing
   *
   * @return windowSize
   **/
  @ApiModelProperty(value = "Width, in minutes, of the time window to use for \"last\" windowing")
  public Long getWindowSize() {
    return windowSize;
  }

  public void setWindowSize(Long windowSize) {
    this.windowSize = windowSize;
  }

  public ChartSettings showHosts(Boolean showHosts) {
    this.showHosts = showHosts;
    return this;
  }

  /**
   * For the tabular view, whether to display sources.  Default: true
   *
   * @return showHosts
   **/
  @ApiModelProperty(value = "For the tabular view, whether to display sources.  Default: true")
  public Boolean isShowHosts() {
    return showHosts;
  }

  public void setShowHosts(Boolean showHosts) {
    this.showHosts = showHosts;
  }

  public ChartSettings showLabels(Boolean showLabels) {
    this.showLabels = showLabels;
    return this;
  }

  /**
   * For the tabular view, whether to display labels.  Default: true
   *
   * @return showLabels
   **/
  @ApiModelProperty(value = "For the tabular view, whether to display labels.  Default: true")
  public Boolean isShowLabels() {
    return showLabels;
  }

  public void setShowLabels(Boolean showLabels) {
    this.showLabels = showLabels;
  }

  public ChartSettings showRawValues(Boolean showRawValues) {
    this.showRawValues = showRawValues;
    return this;
  }

  /**
   * For the tabular view, whether to display raw values.  Default: false
   *
   * @return showRawValues
   **/
  @ApiModelProperty(value = "For the tabular view, whether to display raw values.  Default: false")
  public Boolean isShowRawValues() {
    return showRawValues;
  }

  public void setShowRawValues(Boolean showRawValues) {
    this.showRawValues = showRawValues;
  }

  public ChartSettings autoColumnTags(Boolean autoColumnTags) {
    this.autoColumnTags = autoColumnTags;
    return this;
  }

  /**
   * deprecated
   *
   * @return autoColumnTags
   **/
  @ApiModelProperty(value = "deprecated")
  public Boolean isAutoColumnTags() {
    return autoColumnTags;
  }

  public void setAutoColumnTags(Boolean autoColumnTags) {
    this.autoColumnTags = autoColumnTags;
  }

  public ChartSettings columnTags(String columnTags) {
    this.columnTags = columnTags;
    return this;
  }

  /**
   * deprecated
   *
   * @return columnTags
   **/
  @ApiModelProperty(value = "deprecated")
  public String getColumnTags() {
    return columnTags;
  }

  public void setColumnTags(String columnTags) {
    this.columnTags = columnTags;
  }

  public ChartSettings tagMode(TagModeEnum tagMode) {
    this.tagMode = tagMode;
    return this;
  }

  /**
   * For the tabular view, which mode to use to determine which point tags to display
   *
   * @return tagMode
   **/
  @ApiModelProperty(value = "For the tabular view, which mode to use to determine which point tags to display")
  public TagModeEnum getTagMode() {
    return tagMode;
  }

  public void setTagMode(TagModeEnum tagMode) {
    this.tagMode = tagMode;
  }

  public ChartSettings numTags(Integer numTags) {
    this.numTags = numTags;
    return this;
  }

  /**
   * For the tabular view, how many point tags to display
   *
   * @return numTags
   **/
  @ApiModelProperty(value = "For the tabular view, how many point tags to display")
  public Integer getNumTags() {
    return numTags;
  }

  public void setNumTags(Integer numTags) {
    this.numTags = numTags;
  }

  public ChartSettings customTags(List<String> customTags) {
    this.customTags = customTags;
    return this;
  }

  public ChartSettings addCustomTagsItem(String customTagsItem) {
    if (this.customTags == null) {
      this.customTags = new ArrayList<String>();
    }
    this.customTags.add(customTagsItem);
    return this;
  }

  /**
   * For the tabular view, a list of point tags to display when using the \&quot;custom\&quot; tag display mode
   *
   * @return customTags
   **/
  @ApiModelProperty(value = "For the tabular view, a list of point tags to display when using the \"custom\" tag display mode")
  public List<String> getCustomTags() {
    return customTags;
  }

  public void setCustomTags(List<String> customTags) {
    this.customTags = customTags;
  }

  public ChartSettings groupBySource(Boolean groupBySource) {
    this.groupBySource = groupBySource;
    return this;
  }

  /**
   * For the tabular view, whether to group multi metrics into a single row by a common source.  If false, each metric for each source is displayed in its own row.  If true, multiple metrics for the same host will be displayed as different columns in the same row
   *
   * @return groupBySource
   **/
  @ApiModelProperty(value = "For the tabular view, whether to group multi metrics into a single row by a common source.  If false, each metric for each source is displayed in its own row.  If true, multiple metrics for the same host will be displayed as different columns in the same row")
  public Boolean isGroupBySource() {
    return groupBySource;
  }

  public void setGroupBySource(Boolean groupBySource) {
    this.groupBySource = groupBySource;
  }

  public ChartSettings sortValuesDescending(Boolean sortValuesDescending) {
    this.sortValuesDescending = sortValuesDescending;
    return this;
  }

  /**
   * For the tabular view, whether to display display values in descending order.  Default: false
   *
   * @return sortValuesDescending
   **/
  @ApiModelProperty(value = "For the tabular view, whether to display display values in descending order.  Default: false")
  public Boolean isSortValuesDescending() {
    return sortValuesDescending;
  }

  public void setSortValuesDescending(Boolean sortValuesDescending) {
    this.sortValuesDescending = sortValuesDescending;
  }

  public ChartSettings y1Max(Double y1Max) {
    this.y1Max = y1Max;
    return this;
  }

  /**
   * For plots with multiple Y-axes, max value for right-side Y-axis.  Set null for auto
   *
   * @return y1Max
   **/
  @ApiModelProperty(value = "For plots with multiple Y-axes, max value for right-side Y-axis.  Set null for auto")
  public Double getY1Max() {
    return y1Max;
  }

  public void setY1Max(Double y1Max) {
    this.y1Max = y1Max;
  }

  public ChartSettings fixedLegendPosition(FixedLegendPositionEnum fixedLegendPosition) {
    this.fixedLegendPosition = fixedLegendPosition;
    return this;
  }

  /**
   * Where the fixed legend should be displayed with respect to the chart
   *
   * @return fixedLegendPosition
   **/
  @ApiModelProperty(value = "Where the fixed legend should be displayed with respect to the chart")
  public FixedLegendPositionEnum getFixedLegendPosition() {
    return fixedLegendPosition;
  }

  public void setFixedLegendPosition(FixedLegendPositionEnum fixedLegendPosition) {
    this.fixedLegendPosition = fixedLegendPosition;
  }

  public ChartSettings fixedLegendDisplayStats(List<String> fixedLegendDisplayStats) {
    this.fixedLegendDisplayStats = fixedLegendDisplayStats;
    return this;
  }

  public ChartSettings addFixedLegendDisplayStatsItem(String fixedLegendDisplayStatsItem) {
    if (this.fixedLegendDisplayStats == null) {
      this.fixedLegendDisplayStats = new ArrayList<String>();
    }
    this.fixedLegendDisplayStats.add(fixedLegendDisplayStatsItem);
    return this;
  }

  /**
   * For a chart with a fixed legend, a list of statistics to display in the legend
   *
   * @return fixedLegendDisplayStats
   **/
  @ApiModelProperty(value = "For a chart with a fixed legend, a list of statistics to display in the legend")
  public List<String> getFixedLegendDisplayStats() {
    return fixedLegendDisplayStats;
  }

  public void setFixedLegendDisplayStats(List<String> fixedLegendDisplayStats) {
    this.fixedLegendDisplayStats = fixedLegendDisplayStats;
  }

  public ChartSettings fixedLegendFilterSort(FixedLegendFilterSortEnum fixedLegendFilterSort) {
    this.fixedLegendFilterSort = fixedLegendFilterSort;
    return this;
  }

  /**
   * Whether to display \&quot;Top\&quot;- or \&quot;Bottom\&quot;-ranked series in the fixed legend
   *
   * @return fixedLegendFilterSort
   **/
  @ApiModelProperty(value = "Whether to display \"Top\"- or \"Bottom\"-ranked series in the fixed legend")
  public FixedLegendFilterSortEnum getFixedLegendFilterSort() {
    return fixedLegendFilterSort;
  }

  public void setFixedLegendFilterSort(FixedLegendFilterSortEnum fixedLegendFilterSort) {
    this.fixedLegendFilterSort = fixedLegendFilterSort;
  }

  public ChartSettings fixedLegendFilterLimit(Integer fixedLegendFilterLimit) {
    this.fixedLegendFilterLimit = fixedLegendFilterLimit;
    return this;
  }

  /**
   * Number of series to include in the fixed legend
   *
   * @return fixedLegendFilterLimit
   **/
  @ApiModelProperty(value = "Number of series to include in the fixed legend")
  public Integer getFixedLegendFilterLimit() {
    return fixedLegendFilterLimit;
  }

  public void setFixedLegendFilterLimit(Integer fixedLegendFilterLimit) {
    this.fixedLegendFilterLimit = fixedLegendFilterLimit;
  }

  public ChartSettings ymax(Double ymax) {
    this.ymax = ymax;
    return this;
  }

  /**
   * For x-y scatterplots, max value for Y-axis.  Set null for auto
   *
   * @return ymax
   **/
  @ApiModelProperty(value = "For x-y scatterplots, max value for Y-axis.  Set null for auto")
  public Double getYmax() {
    return ymax;
  }

  public void setYmax(Double ymax) {
    this.ymax = ymax;
  }

  public ChartSettings ymin(Double ymin) {
    this.ymin = ymin;
    return this;
  }

  /**
   * For x-y scatterplots, min value for Y-axis.  Set null for auto
   *
   * @return ymin
   **/
  @ApiModelProperty(value = "For x-y scatterplots, min value for Y-axis.  Set null for auto")
  public Double getYmin() {
    return ymin;
  }

  public void setYmin(Double ymin) {
    this.ymin = ymin;
  }

  public ChartSettings timeBasedColoring(Boolean timeBasedColoring) {
    this.timeBasedColoring = timeBasedColoring;
    return this;
  }

  /**
   * Fox x-y scatterplots, whether to color more recent points as darker than older points. Default: false
   *
   * @return timeBasedColoring
   **/
  @ApiModelProperty(value = "Fox x-y scatterplots, whether to color more recent points as darker than older points. Default: false")
  public Boolean isTimeBasedColoring() {
    return timeBasedColoring;
  }

  public void setTimeBasedColoring(Boolean timeBasedColoring) {
    this.timeBasedColoring = timeBasedColoring;
  }

  public ChartSettings sparklineDisplayValueType(SparklineDisplayValueTypeEnum sparklineDisplayValueType) {
    this.sparklineDisplayValueType = sparklineDisplayValueType;
    return this;
  }

  /**
   * For the single stat view, whether to display the name of the query or the value of query
   *
   * @return sparklineDisplayValueType
   **/
  @ApiModelProperty(value = "For the single stat view, whether to display the name of the query or the value of query")
  public SparklineDisplayValueTypeEnum getSparklineDisplayValueType() {
    return sparklineDisplayValueType;
  }

  public void setSparklineDisplayValueType(SparklineDisplayValueTypeEnum sparklineDisplayValueType) {
    this.sparklineDisplayValueType = sparklineDisplayValueType;
  }

  public ChartSettings fixedLegendFilterField(FixedLegendFilterFieldEnum fixedLegendFilterField) {
    this.fixedLegendFilterField = fixedLegendFilterField;
    return this;
  }

  /**
   * Statistic to use for determining whether a series is displayed on the fixed legend
   *
   * @return fixedLegendFilterField
   **/
  @ApiModelProperty(value = "Statistic to use for determining whether a series is displayed on the fixed legend")
  public FixedLegendFilterFieldEnum getFixedLegendFilterField() {
    return fixedLegendFilterField;
  }

  public void setFixedLegendFilterField(FixedLegendFilterFieldEnum fixedLegendFilterField) {
    this.fixedLegendFilterField = fixedLegendFilterField;
  }

  public ChartSettings fixedLegendHideLabel(Boolean fixedLegendHideLabel) {
    this.fixedLegendHideLabel = fixedLegendHideLabel;
    return this;
  }

  /**
   * deprecated
   *
   * @return fixedLegendHideLabel
   **/
  @ApiModelProperty(value = "deprecated")
  public Boolean isFixedLegendHideLabel() {
    return fixedLegendHideLabel;
  }

  public void setFixedLegendHideLabel(Boolean fixedLegendHideLabel) {
    this.fixedLegendHideLabel = fixedLegendHideLabel;
  }

  public ChartSettings xmax(Double xmax) {
    this.xmax = xmax;
    return this;
  }

  /**
   * For x-y scatterplots, max value for X-axis.  Set null for auto
   *
   * @return xmax
   **/
  @ApiModelProperty(value = "For x-y scatterplots, max value for X-axis.  Set null for auto")
  public Double getXmax() {
    return xmax;
  }

  public void setXmax(Double xmax) {
    this.xmax = xmax;
  }

  public ChartSettings xmin(Double xmin) {
    this.xmin = xmin;
    return this;
  }

  /**
   * For x-y scatterplots, min value for X-axis.  Set null for auto
   *
   * @return xmin
   **/
  @ApiModelProperty(value = "For x-y scatterplots, min value for X-axis.  Set null for auto")
  public Double getXmin() {
    return xmin;
  }

  public void setXmin(Double xmin) {
    this.xmin = xmin;
  }

  public ChartSettings y1UnitAutoscaling(Boolean y1UnitAutoscaling) {
    this.y1UnitAutoscaling = y1UnitAutoscaling;
    return this;
  }

  /**
   * Default: false. Whether to automatically adjust magnitude labels and units for the right Y-axis to favor smaller magnitudes and larger units
   *
   * @return y1UnitAutoscaling
   **/
  @ApiModelProperty(value = "Default: false. Whether to automatically adjust magnitude labels and units for the right Y-axis to favor smaller magnitudes and larger units")
  public Boolean isY1UnitAutoscaling() {
    return y1UnitAutoscaling;
  }

  public void setY1UnitAutoscaling(Boolean y1UnitAutoscaling) {
    this.y1UnitAutoscaling = y1UnitAutoscaling;
  }

  public ChartSettings invertDynamicLegendHoverControl(Boolean invertDynamicLegendHoverControl) {
    this.invertDynamicLegendHoverControl = invertDynamicLegendHoverControl;
    return this;
  }

  /**
   * Whether to disable the display of the floating legend (but reenable it when the ctrl-key is pressed)
   *
   * @return invertDynamicLegendHoverControl
   **/
  @ApiModelProperty(value = "Whether to disable the display of the floating legend (but reenable it when the ctrl-key is pressed)")
  public Boolean isInvertDynamicLegendHoverControl() {
    return invertDynamicLegendHoverControl;
  }

  public void setInvertDynamicLegendHoverControl(Boolean invertDynamicLegendHoverControl) {
    this.invertDynamicLegendHoverControl = invertDynamicLegendHoverControl;
  }

  public ChartSettings fixedLegendEnabled(Boolean fixedLegendEnabled) {
    this.fixedLegendEnabled = fixedLegendEnabled;
    return this;
  }

  /**
   * Whether to enable a fixed tabular legend adjacent to the chart
   *
   * @return fixedLegendEnabled
   **/
  @ApiModelProperty(value = "Whether to enable a fixed tabular legend adjacent to the chart")
  public Boolean isFixedLegendEnabled() {
    return fixedLegendEnabled;
  }

  public void setFixedLegendEnabled(Boolean fixedLegendEnabled) {
    this.fixedLegendEnabled = fixedLegendEnabled;
  }

  public ChartSettings fixedLegendUseRawStats(Boolean fixedLegendUseRawStats) {
    this.fixedLegendUseRawStats = fixedLegendUseRawStats;
    return this;
  }

  /**
   * If true, the legend uses non-summarized stats instead of summarized
   *
   * @return fixedLegendUseRawStats
   **/
  @ApiModelProperty(value = "If true, the legend uses non-summarized stats instead of summarized")
  public Boolean isFixedLegendUseRawStats() {
    return fixedLegendUseRawStats;
  }

  public void setFixedLegendUseRawStats(Boolean fixedLegendUseRawStats) {
    this.fixedLegendUseRawStats = fixedLegendUseRawStats;
  }

  public ChartSettings sparklineDisplayPrefix(String sparklineDisplayPrefix) {
    this.sparklineDisplayPrefix = sparklineDisplayPrefix;
    return this;
  }

  /**
   * For the single stat view, a string to add before the displayed text
   *
   * @return sparklineDisplayPrefix
   **/
  @ApiModelProperty(value = "For the single stat view, a string to add before the displayed text")
  public String getSparklineDisplayPrefix() {
    return sparklineDisplayPrefix;
  }

  public void setSparklineDisplayPrefix(String sparklineDisplayPrefix) {
    this.sparklineDisplayPrefix = sparklineDisplayPrefix;
  }

  public ChartSettings sparklineDisplayPostfix(String sparklineDisplayPostfix) {
    this.sparklineDisplayPostfix = sparklineDisplayPostfix;
    return this;
  }

  /**
   * For the single stat view, a string to append to the displayed text
   *
   * @return sparklineDisplayPostfix
   **/
  @ApiModelProperty(value = "For the single stat view, a string to append to the displayed text")
  public String getSparklineDisplayPostfix() {
    return sparklineDisplayPostfix;
  }

  public void setSparklineDisplayPostfix(String sparklineDisplayPostfix) {
    this.sparklineDisplayPostfix = sparklineDisplayPostfix;
  }

  public ChartSettings sparklineSize(SparklineSizeEnum sparklineSize) {
    this.sparklineSize = sparklineSize;
    return this;
  }

  /**
   * For the single stat view, a misleadingly named property.  This determines whether the sparkline of the statistic is displayed in the chart BACKGROUND, BOTTOM, or NONE
   *
   * @return sparklineSize
   **/
  @ApiModelProperty(value = "For the single stat view, a misleadingly named property.  This determines whether the sparkline of the statistic is displayed in the chart BACKGROUND, BOTTOM, or NONE")
  public SparklineSizeEnum getSparklineSize() {
    return sparklineSize;
  }

  public void setSparklineSize(SparklineSizeEnum sparklineSize) {
    this.sparklineSize = sparklineSize;
  }

  public ChartSettings sparklineLineColor(String sparklineLineColor) {
    this.sparklineLineColor = sparklineLineColor;
    return this;
  }

  /**
   * For the single stat view, the color of the line. Values should be in\&quot;rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;\&quot; format
   *
   * @return sparklineLineColor
   **/
  @ApiModelProperty(value = "For the single stat view, the color of the line. Values should be in\"rgba(<rval>, <gval>, <bval>, <aval>\" format")
  public String getSparklineLineColor() {
    return sparklineLineColor;
  }

  public void setSparklineLineColor(String sparklineLineColor) {
    this.sparklineLineColor = sparklineLineColor;
  }

  public ChartSettings sparklineDecimalPrecision(Integer sparklineDecimalPrecision) {
    this.sparklineDecimalPrecision = sparklineDecimalPrecision;
    return this;
  }

  /**
   * For the single stat view, the decimal precision of the displayed number
   *
   * @return sparklineDecimalPrecision
   **/
  @ApiModelProperty(value = "For the single stat view, the decimal precision of the displayed number")
  public Integer getSparklineDecimalPrecision() {
    return sparklineDecimalPrecision;
  }

  public void setSparklineDecimalPrecision(Integer sparklineDecimalPrecision) {
    this.sparklineDecimalPrecision = sparklineDecimalPrecision;
  }

  public ChartSettings sparklineValueTextMapText(List<String> sparklineValueTextMapText) {
    this.sparklineValueTextMapText = sparklineValueTextMapText;
    return this;
  }

  public ChartSettings addSparklineValueTextMapTextItem(String sparklineValueTextMapTextItem) {
    if (this.sparklineValueTextMapText == null) {
      this.sparklineValueTextMapText = new ArrayList<String>();
    }
    this.sparklineValueTextMapText.add(sparklineValueTextMapTextItem);
    return this;
  }

  /**
   * For the single stat view, a list of display text values that different query values map to.  Must contain one more element than sparklineValueTextMapThresholds
   *
   * @return sparklineValueTextMapText
   **/
  @ApiModelProperty(value = "For the single stat view, a list of display text values that different query values map to.  Must contain one more element than sparklineValueTextMapThresholds")
  public List<String> getSparklineValueTextMapText() {
    return sparklineValueTextMapText;
  }

  public void setSparklineValueTextMapText(List<String> sparklineValueTextMapText) {
    this.sparklineValueTextMapText = sparklineValueTextMapText;
  }

  public ChartSettings sparklineValueTextMapThresholds(List<Float> sparklineValueTextMapThresholds) {
    this.sparklineValueTextMapThresholds = sparklineValueTextMapThresholds;
    return this;
  }

  public ChartSettings addSparklineValueTextMapThresholdsItem(Float sparklineValueTextMapThresholdsItem) {
    if (this.sparklineValueTextMapThresholds == null) {
      this.sparklineValueTextMapThresholds = new ArrayList<Float>();
    }
    this.sparklineValueTextMapThresholds.add(sparklineValueTextMapThresholdsItem);
    return this;
  }

  /**
   * For the single stat view, a list of threshold boundaries for mapping different query values to display text. Must contain one less element than sparklineValueTextMapText
   *
   * @return sparklineValueTextMapThresholds
   **/
  @ApiModelProperty(value = "For the single stat view, a list of threshold boundaries for mapping different query values to display text. Must contain one less element than sparklineValueTextMapText")
  public List<Float> getSparklineValueTextMapThresholds() {
    return sparklineValueTextMapThresholds;
  }

  public void setSparklineValueTextMapThresholds(List<Float> sparklineValueTextMapThresholds) {
    this.sparklineValueTextMapThresholds = sparklineValueTextMapThresholds;
  }

  public ChartSettings sparklineFillColor(String sparklineFillColor) {
    this.sparklineFillColor = sparklineFillColor;
    return this;
  }

  /**
   * For the single stat view, the color of the background fill. Values should be in\&quot;rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;\&quot; format
   *
   * @return sparklineFillColor
   **/
  @ApiModelProperty(value = "For the single stat view, the color of the background fill. Values should be in\"rgba(<rval>, <gval>, <bval>, <aval>\" format")
  public String getSparklineFillColor() {
    return sparklineFillColor;
  }

  public void setSparklineFillColor(String sparklineFillColor) {
    this.sparklineFillColor = sparklineFillColor;
  }

  public ChartSettings sparklineValueColorMapColors(List<String> sparklineValueColorMapColors) {
    this.sparklineValueColorMapColors = sparklineValueColorMapColors;
    return this;
  }

  public ChartSettings addSparklineValueColorMapColorsItem(String sparklineValueColorMapColorsItem) {
    if (this.sparklineValueColorMapColors == null) {
      this.sparklineValueColorMapColors = new ArrayList<String>();
    }
    this.sparklineValueColorMapColors.add(sparklineValueColorMapColorsItem);
    return this;
  }

  /**
   * For the single stat view, a list of colors that differing query values map to.  Must contain one more element than sparklineValueColorMapValuesV2. Values should be in\&quot;rgba(&lt;rval&gt;, &lt;gval&gt;, &lt;bval&gt;, &lt;aval&gt;\&quot; format
   *
   * @return sparklineValueColorMapColors
   **/
  @ApiModelProperty(value = "For the single stat view, a list of colors that differing query values map to.  Must contain one more element than sparklineValueColorMapValuesV2. Values should be in\"rgba(<rval>, <gval>, <bval>, <aval>\" format")
  public List<String> getSparklineValueColorMapColors() {
    return sparklineValueColorMapColors;
  }

  public void setSparklineValueColorMapColors(List<String> sparklineValueColorMapColors) {
    this.sparklineValueColorMapColors = sparklineValueColorMapColors;
  }

  public ChartSettings sparklineValueColorMapValuesV2(List<Float> sparklineValueColorMapValuesV2) {
    this.sparklineValueColorMapValuesV2 = sparklineValueColorMapValuesV2;
    return this;
  }

  public ChartSettings addSparklineValueColorMapValuesV2Item(Float sparklineValueColorMapValuesV2Item) {
    if (this.sparklineValueColorMapValuesV2 == null) {
      this.sparklineValueColorMapValuesV2 = new ArrayList<Float>();
    }
    this.sparklineValueColorMapValuesV2.add(sparklineValueColorMapValuesV2Item);
    return this;
  }

  /**
   * For the single stat view, a list of boundaries for mapping different query values to colors.  Must contain one less element than sparklineValueColorMapColors
   *
   * @return sparklineValueColorMapValuesV2
   **/
  @ApiModelProperty(value = "For the single stat view, a list of boundaries for mapping different query values to colors.  Must contain one less element than sparklineValueColorMapColors")
  public List<Float> getSparklineValueColorMapValuesV2() {
    return sparklineValueColorMapValuesV2;
  }

  public void setSparklineValueColorMapValuesV2(List<Float> sparklineValueColorMapValuesV2) {
    this.sparklineValueColorMapValuesV2 = sparklineValueColorMapValuesV2;
  }

  public ChartSettings y1Min(Double y1Min) {
    this.y1Min = y1Min;
    return this;
  }

  /**
   * For plots with multiple Y-axes, min value for right-side Y-axis.  Set null for auto
   *
   * @return y1Min
   **/
  @ApiModelProperty(value = "For plots with multiple Y-axes, min value for right-side Y-axis.  Set null for auto")
  public Double getY1Min() {
    return y1Min;
  }

  public void setY1Min(Double y1Min) {
    this.y1Min = y1Min;
  }

  public ChartSettings y1Units(String y1Units) {
    this.y1Units = y1Units;
    return this;
  }

  /**
   * For plots with multiple Y-axes, units for right-side Y-axis
   *
   * @return y1Units
   **/
  @ApiModelProperty(value = "For plots with multiple Y-axes, units for right-side Y-axis")
  public String getY1Units() {
    return y1Units;
  }

  public void setY1Units(String y1Units) {
    this.y1Units = y1Units;
  }

  public ChartSettings y0ScaleSIBy1024(Boolean y0ScaleSIBy1024) {
    this.y0ScaleSIBy1024 = y0ScaleSIBy1024;
    return this;
  }

  /**
   * Default: false. Whether to scale numerical magnitude labels for left Y-axis by 1024 in the IEC/Binary manner (instead of by 1000 like SI)
   *
   * @return y0ScaleSIBy1024
   **/
  @ApiModelProperty(value = "Default: false. Whether to scale numerical magnitude labels for left Y-axis by 1024 in the IEC/Binary manner (instead of by 1000 like SI)")
  public Boolean isY0ScaleSIBy1024() {
    return y0ScaleSIBy1024;
  }

  public void setY0ScaleSIBy1024(Boolean y0ScaleSIBy1024) {
    this.y0ScaleSIBy1024 = y0ScaleSIBy1024;
  }

  public ChartSettings y1ScaleSIBy1024(Boolean y1ScaleSIBy1024) {
    this.y1ScaleSIBy1024 = y1ScaleSIBy1024;
    return this;
  }

  /**
   * Default: false. Whether to scale numerical magnitude labels for right Y-axis by 1024 in the IEC/Binary manner (instead of by 1000 like SI)
   *
   * @return y1ScaleSIBy1024
   **/
  @ApiModelProperty(value = "Default: false. Whether to scale numerical magnitude labels for right Y-axis by 1024 in the IEC/Binary manner (instead of by 1000 like SI)")
  public Boolean isY1ScaleSIBy1024() {
    return y1ScaleSIBy1024;
  }

  public void setY1ScaleSIBy1024(Boolean y1ScaleSIBy1024) {
    this.y1ScaleSIBy1024 = y1ScaleSIBy1024;
  }

  public ChartSettings y0UnitAutoscaling(Boolean y0UnitAutoscaling) {
    this.y0UnitAutoscaling = y0UnitAutoscaling;
    return this;
  }

  /**
   * Default: false. Whether to automatically adjust magnitude labels and units for the left Y-axis to favor smaller magnitudes and larger units
   *
   * @return y0UnitAutoscaling
   **/
  @ApiModelProperty(value = "Default: false. Whether to automatically adjust magnitude labels and units for the left Y-axis to favor smaller magnitudes and larger units")
  public Boolean isY0UnitAutoscaling() {
    return y0UnitAutoscaling;
  }

  public void setY0UnitAutoscaling(Boolean y0UnitAutoscaling) {
    this.y0UnitAutoscaling = y0UnitAutoscaling;
  }

  public ChartSettings sparklineValueColorMapValues(List<Long> sparklineValueColorMapValues) {
    this.sparklineValueColorMapValues = sparklineValueColorMapValues;
    return this;
  }

  public ChartSettings addSparklineValueColorMapValuesItem(Long sparklineValueColorMapValuesItem) {
    if (this.sparklineValueColorMapValues == null) {
      this.sparklineValueColorMapValues = new ArrayList<Long>();
    }
    this.sparklineValueColorMapValues.add(sparklineValueColorMapValuesItem);
    return this;
  }

  /**
   * deprecated
   *
   * @return sparklineValueColorMapValues
   **/
  @ApiModelProperty(value = "deprecated")
  public List<Long> getSparklineValueColorMapValues() {
    return sparklineValueColorMapValues;
  }

  public void setSparklineValueColorMapValues(List<Long> sparklineValueColorMapValues) {
    this.sparklineValueColorMapValues = sparklineValueColorMapValues;
  }

  public ChartSettings sparklineValueColorMapApplyTo(SparklineValueColorMapApplyToEnum sparklineValueColorMapApplyTo) {
    this.sparklineValueColorMapApplyTo = sparklineValueColorMapApplyTo;
    return this;
  }

  /**
   * For the single stat view, whether to apply dynamic color settings to the displayed TEXT or BACKGROUND
   *
   * @return sparklineValueColorMapApplyTo
   **/
  @ApiModelProperty(value = "For the single stat view, whether to apply dynamic color settings to the displayed TEXT or BACKGROUND")
  public SparklineValueColorMapApplyToEnum getSparklineValueColorMapApplyTo() {
    return sparklineValueColorMapApplyTo;
  }

  public void setSparklineValueColorMapApplyTo(SparklineValueColorMapApplyToEnum sparklineValueColorMapApplyTo) {
    this.sparklineValueColorMapApplyTo = sparklineValueColorMapApplyTo;
  }

  public ChartSettings max(Double max) {
    this.max = max;
    return this;
  }

  /**
   * Max value of Y-axis.  Set to null or leave blank for auto
   *
   * @return max
   **/
  @ApiModelProperty(value = "Max value of Y-axis.  Set to null or leave blank for auto")
  public Double getMax() {
    return max;
  }

  public void setMax(Double max) {
    this.max = max;
  }

  public ChartSettings expectedDataSpacing(Long expectedDataSpacing) {
    this.expectedDataSpacing = expectedDataSpacing;
    return this;
  }

  /**
   * Threshold (in seconds) for time delta between consecutive points in a series above which a dotted line will replace a solid line in line plots.  Default: 60s
   *
   * @return expectedDataSpacing
   **/
  @ApiModelProperty(value = "Threshold (in seconds) for time delta between consecutive points in a series above which a dotted line will replace a solid line in line plots.  Default: 60s")
  public Long getExpectedDataSpacing() {
    return expectedDataSpacing;
  }

  public void setExpectedDataSpacing(Long expectedDataSpacing) {
    this.expectedDataSpacing = expectedDataSpacing;
  }

  public ChartSettings plainMarkdownContent(String plainMarkdownContent) {
    this.plainMarkdownContent = plainMarkdownContent;
    return this;
  }

  /**
   * The Markdown content for a Markdown display, in plain text.  Use this field instead of &#x60;markdownContent&#x60;.
   *
   * @return plainMarkdownContent
   **/
  @ApiModelProperty(value = "The Markdown content for a Markdown display, in plain text.  Use this field instead of `markdownContent`.")
  public String getPlainMarkdownContent() {
    return plainMarkdownContent;
  }

  public void setPlainMarkdownContent(String plainMarkdownContent) {
    this.plainMarkdownContent = plainMarkdownContent;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChartSettings chartSettings = (ChartSettings) o;
    return Objects.equals(this.type, chartSettings.type) &&
        Objects.equals(this.min, chartSettings.min) &&
        Objects.equals(this.sparklineDisplayColor, chartSettings.sparklineDisplayColor) &&
        Objects.equals(this.sparklineDisplayVerticalPosition, chartSettings.sparklineDisplayVerticalPosition) &&
        Objects.equals(this.sparklineDisplayHorizontalPosition, chartSettings.sparklineDisplayHorizontalPosition) &&
        Objects.equals(this.sparklineDisplayFontSize, chartSettings.sparklineDisplayFontSize) &&
        Objects.equals(this.lineType, chartSettings.lineType) &&
        Objects.equals(this.stackType, chartSettings.stackType) &&
        Objects.equals(this.windowing, chartSettings.windowing) &&
        Objects.equals(this.windowSize, chartSettings.windowSize) &&
        Objects.equals(this.showHosts, chartSettings.showHosts) &&
        Objects.equals(this.showLabels, chartSettings.showLabels) &&
        Objects.equals(this.showRawValues, chartSettings.showRawValues) &&
        Objects.equals(this.autoColumnTags, chartSettings.autoColumnTags) &&
        Objects.equals(this.columnTags, chartSettings.columnTags) &&
        Objects.equals(this.tagMode, chartSettings.tagMode) &&
        Objects.equals(this.numTags, chartSettings.numTags) &&
        Objects.equals(this.customTags, chartSettings.customTags) &&
        Objects.equals(this.groupBySource, chartSettings.groupBySource) &&
        Objects.equals(this.sortValuesDescending, chartSettings.sortValuesDescending) &&
        Objects.equals(this.y1Max, chartSettings.y1Max) &&
        Objects.equals(this.fixedLegendPosition, chartSettings.fixedLegendPosition) &&
        Objects.equals(this.fixedLegendDisplayStats, chartSettings.fixedLegendDisplayStats) &&
        Objects.equals(this.fixedLegendFilterSort, chartSettings.fixedLegendFilterSort) &&
        Objects.equals(this.fixedLegendFilterLimit, chartSettings.fixedLegendFilterLimit) &&
        Objects.equals(this.ymax, chartSettings.ymax) &&
        Objects.equals(this.ymin, chartSettings.ymin) &&
        Objects.equals(this.timeBasedColoring, chartSettings.timeBasedColoring) &&
        Objects.equals(this.sparklineDisplayValueType, chartSettings.sparklineDisplayValueType) &&
        Objects.equals(this.fixedLegendFilterField, chartSettings.fixedLegendFilterField) &&
        Objects.equals(this.fixedLegendHideLabel, chartSettings.fixedLegendHideLabel) &&
        Objects.equals(this.xmax, chartSettings.xmax) &&
        Objects.equals(this.xmin, chartSettings.xmin) &&
        Objects.equals(this.y1UnitAutoscaling, chartSettings.y1UnitAutoscaling) &&
        Objects.equals(this.invertDynamicLegendHoverControl, chartSettings.invertDynamicLegendHoverControl) &&
        Objects.equals(this.fixedLegendEnabled, chartSettings.fixedLegendEnabled) &&
        Objects.equals(this.fixedLegendUseRawStats, chartSettings.fixedLegendUseRawStats) &&
        Objects.equals(this.sparklineDisplayPrefix, chartSettings.sparklineDisplayPrefix) &&
        Objects.equals(this.sparklineDisplayPostfix, chartSettings.sparklineDisplayPostfix) &&
        Objects.equals(this.sparklineSize, chartSettings.sparklineSize) &&
        Objects.equals(this.sparklineLineColor, chartSettings.sparklineLineColor) &&
        Objects.equals(this.sparklineDecimalPrecision, chartSettings.sparklineDecimalPrecision) &&
        Objects.equals(this.sparklineValueTextMapText, chartSettings.sparklineValueTextMapText) &&
        Objects.equals(this.sparklineValueTextMapThresholds, chartSettings.sparklineValueTextMapThresholds) &&
        Objects.equals(this.sparklineFillColor, chartSettings.sparklineFillColor) &&
        Objects.equals(this.sparklineValueColorMapColors, chartSettings.sparklineValueColorMapColors) &&
        Objects.equals(this.sparklineValueColorMapValuesV2, chartSettings.sparklineValueColorMapValuesV2) &&
        Objects.equals(this.y1Min, chartSettings.y1Min) &&
        Objects.equals(this.y1Units, chartSettings.y1Units) &&
        Objects.equals(this.y0ScaleSIBy1024, chartSettings.y0ScaleSIBy1024) &&
        Objects.equals(this.y1ScaleSIBy1024, chartSettings.y1ScaleSIBy1024) &&
        Objects.equals(this.y0UnitAutoscaling, chartSettings.y0UnitAutoscaling) &&
        Objects.equals(this.sparklineValueColorMapValues, chartSettings.sparklineValueColorMapValues) &&
        Objects.equals(this.sparklineValueColorMapApplyTo, chartSettings.sparklineValueColorMapApplyTo) &&
        Objects.equals(this.max, chartSettings.max) &&
        Objects.equals(this.expectedDataSpacing, chartSettings.expectedDataSpacing) &&
        Objects.equals(this.plainMarkdownContent, chartSettings.plainMarkdownContent);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, min, sparklineDisplayColor, sparklineDisplayVerticalPosition, sparklineDisplayHorizontalPosition, sparklineDisplayFontSize, lineType, stackType, windowing, windowSize, showHosts, showLabels, showRawValues, autoColumnTags, columnTags, tagMode, numTags, customTags, groupBySource, sortValuesDescending, y1Max, fixedLegendPosition, fixedLegendDisplayStats, fixedLegendFilterSort, fixedLegendFilterLimit, ymax, ymin, timeBasedColoring, sparklineDisplayValueType, fixedLegendFilterField, fixedLegendHideLabel, xmax, xmin, y1UnitAutoscaling, invertDynamicLegendHoverControl, fixedLegendEnabled, fixedLegendUseRawStats, sparklineDisplayPrefix, sparklineDisplayPostfix, sparklineSize, sparklineLineColor, sparklineDecimalPrecision, sparklineValueTextMapText, sparklineValueTextMapThresholds, sparklineFillColor, sparklineValueColorMapColors, sparklineValueColorMapValuesV2, y1Min, y1Units, y0ScaleSIBy1024, y1ScaleSIBy1024, y0UnitAutoscaling, sparklineValueColorMapValues, sparklineValueColorMapApplyTo, max, expectedDataSpacing, plainMarkdownContent);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChartSettings {\n");

    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    min: ").append(toIndentedString(min)).append("\n");
    sb.append("    sparklineDisplayColor: ").append(toIndentedString(sparklineDisplayColor)).append("\n");
    sb.append("    sparklineDisplayVerticalPosition: ").append(toIndentedString(sparklineDisplayVerticalPosition)).append("\n");
    sb.append("    sparklineDisplayHorizontalPosition: ").append(toIndentedString(sparklineDisplayHorizontalPosition)).append("\n");
    sb.append("    sparklineDisplayFontSize: ").append(toIndentedString(sparklineDisplayFontSize)).append("\n");
    sb.append("    lineType: ").append(toIndentedString(lineType)).append("\n");
    sb.append("    stackType: ").append(toIndentedString(stackType)).append("\n");
    sb.append("    windowing: ").append(toIndentedString(windowing)).append("\n");
    sb.append("    windowSize: ").append(toIndentedString(windowSize)).append("\n");
    sb.append("    showHosts: ").append(toIndentedString(showHosts)).append("\n");
    sb.append("    showLabels: ").append(toIndentedString(showLabels)).append("\n");
    sb.append("    showRawValues: ").append(toIndentedString(showRawValues)).append("\n");
    sb.append("    autoColumnTags: ").append(toIndentedString(autoColumnTags)).append("\n");
    sb.append("    columnTags: ").append(toIndentedString(columnTags)).append("\n");
    sb.append("    tagMode: ").append(toIndentedString(tagMode)).append("\n");
    sb.append("    numTags: ").append(toIndentedString(numTags)).append("\n");
    sb.append("    customTags: ").append(toIndentedString(customTags)).append("\n");
    sb.append("    groupBySource: ").append(toIndentedString(groupBySource)).append("\n");
    sb.append("    sortValuesDescending: ").append(toIndentedString(sortValuesDescending)).append("\n");
    sb.append("    y1Max: ").append(toIndentedString(y1Max)).append("\n");
    sb.append("    fixedLegendPosition: ").append(toIndentedString(fixedLegendPosition)).append("\n");
    sb.append("    fixedLegendDisplayStats: ").append(toIndentedString(fixedLegendDisplayStats)).append("\n");
    sb.append("    fixedLegendFilterSort: ").append(toIndentedString(fixedLegendFilterSort)).append("\n");
    sb.append("    fixedLegendFilterLimit: ").append(toIndentedString(fixedLegendFilterLimit)).append("\n");
    sb.append("    ymax: ").append(toIndentedString(ymax)).append("\n");
    sb.append("    ymin: ").append(toIndentedString(ymin)).append("\n");
    sb.append("    timeBasedColoring: ").append(toIndentedString(timeBasedColoring)).append("\n");
    sb.append("    sparklineDisplayValueType: ").append(toIndentedString(sparklineDisplayValueType)).append("\n");
    sb.append("    fixedLegendFilterField: ").append(toIndentedString(fixedLegendFilterField)).append("\n");
    sb.append("    fixedLegendHideLabel: ").append(toIndentedString(fixedLegendHideLabel)).append("\n");
    sb.append("    xmax: ").append(toIndentedString(xmax)).append("\n");
    sb.append("    xmin: ").append(toIndentedString(xmin)).append("\n");
    sb.append("    y1UnitAutoscaling: ").append(toIndentedString(y1UnitAutoscaling)).append("\n");
    sb.append("    invertDynamicLegendHoverControl: ").append(toIndentedString(invertDynamicLegendHoverControl)).append("\n");
    sb.append("    fixedLegendEnabled: ").append(toIndentedString(fixedLegendEnabled)).append("\n");
    sb.append("    fixedLegendUseRawStats: ").append(toIndentedString(fixedLegendUseRawStats)).append("\n");
    sb.append("    sparklineDisplayPrefix: ").append(toIndentedString(sparklineDisplayPrefix)).append("\n");
    sb.append("    sparklineDisplayPostfix: ").append(toIndentedString(sparklineDisplayPostfix)).append("\n");
    sb.append("    sparklineSize: ").append(toIndentedString(sparklineSize)).append("\n");
    sb.append("    sparklineLineColor: ").append(toIndentedString(sparklineLineColor)).append("\n");
    sb.append("    sparklineDecimalPrecision: ").append(toIndentedString(sparklineDecimalPrecision)).append("\n");
    sb.append("    sparklineValueTextMapText: ").append(toIndentedString(sparklineValueTextMapText)).append("\n");
    sb.append("    sparklineValueTextMapThresholds: ").append(toIndentedString(sparklineValueTextMapThresholds)).append("\n");
    sb.append("    sparklineFillColor: ").append(toIndentedString(sparklineFillColor)).append("\n");
    sb.append("    sparklineValueColorMapColors: ").append(toIndentedString(sparklineValueColorMapColors)).append("\n");
    sb.append("    sparklineValueColorMapValuesV2: ").append(toIndentedString(sparklineValueColorMapValuesV2)).append("\n");
    sb.append("    y1Min: ").append(toIndentedString(y1Min)).append("\n");
    sb.append("    y1Units: ").append(toIndentedString(y1Units)).append("\n");
    sb.append("    y0ScaleSIBy1024: ").append(toIndentedString(y0ScaleSIBy1024)).append("\n");
    sb.append("    y1ScaleSIBy1024: ").append(toIndentedString(y1ScaleSIBy1024)).append("\n");
    sb.append("    y0UnitAutoscaling: ").append(toIndentedString(y0UnitAutoscaling)).append("\n");
    sb.append("    sparklineValueColorMapValues: ").append(toIndentedString(sparklineValueColorMapValues)).append("\n");
    sb.append("    sparklineValueColorMapApplyTo: ").append(toIndentedString(sparklineValueColorMapApplyTo)).append("\n");
    sb.append("    max: ").append(toIndentedString(max)).append("\n");
    sb.append("    expectedDataSpacing: ").append(toIndentedString(expectedDataSpacing)).append("\n");
    sb.append("    plainMarkdownContent: ").append(toIndentedString(plainMarkdownContent)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

