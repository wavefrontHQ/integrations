/*
 * Wavefront REST API
 * <p>The Wavefront REST API enables you to interact with Wavefront servers using standard REST API tools. You can use the REST API to automate commonly executed operations such as automatically tagging sources.</p><p>When you make REST API calls outside the Wavefront REST API documentation you must add the header \"Authorization: Bearer &lt;&lt;API-TOKEN&gt;&gt;\" to your HTTP requests.</p>
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.wavefront.rest.api.client;

import com.wavefront.rest.api.ApiCallback;
import com.wavefront.rest.api.ApiClient;
import com.wavefront.rest.api.ApiException;
import com.wavefront.rest.api.ApiResponse;
import com.wavefront.rest.api.Configuration;
import com.wavefront.rest.api.Pair;
import com.wavefront.rest.api.ProgressRequestBody;
import com.wavefront.rest.api.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.wavefront.rest.models.QueryResult;
import com.wavefront.rest.models.RawTimeseries;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class QueryApi {
  private ApiClient apiClient;

  public QueryApi() {
    this(Configuration.getDefaultApiClient());
  }

  public QueryApi(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Build call for queryApi
   *
   * @param q                       the query expression to execute (required)
   * @param s                       the start time of the query window in epoch milliseconds (required)
   * @param g                       the granularity of the points returned (required)
   * @param n                       name used to identify the query (optional)
   * @param e                       the end time of the query window in epoch milliseconds (null to use now) (optional)
   * @param p                       the approximate maximum number of points to return (may not limit number of points exactly) (optional)
   * @param i                       whether series with only points that are outside of the query window will be returned (defaults to true) (optional)
   * @param autoEvents              whether events for sources included in the query will be automatically returned by the query (optional)
   * @param summarization           summarization strategy to use when bucketing points together (optional)
   * @param listMode                retrieve events more optimally displayed for a list (optional)
   * @param strict                  do not return points outside the query window [s;e), defaults to false (optional)
   * @param includeObsoleteMetrics  include metrics that have not been reporting recently, defaults to false (optional)
   * @param sorted                  sorts the output so that returned series are in order, defaults to false (optional, default to false)
   * @param cached                  whether the query cache is used, defaults to true (optional, default to true)
   * @param progressListener        Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call queryApiCall(String q, String s, String g, String n, String e, String p, Boolean i, Boolean autoEvents, String summarization, Boolean listMode, Boolean strict, Boolean includeObsoleteMetrics, Boolean sorted, Boolean cached, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/api/v2/chart/api";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (n != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("n", n));
    if (q != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    if (s != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("s", s));
    if (e != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("e", e));
    if (g != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("g", g));
    if (p != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("p", p));
    if (i != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("i", i));
    if (autoEvents != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("autoEvents", autoEvents));
    if (summarization != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("summarization", summarization));
    if (listMode != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("listMode", listMode));
    if (strict != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("strict", strict));
    if (includeObsoleteMetrics != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("includeObsoleteMetrics", includeObsoleteMetrics));
    if (sorted != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("sorted", sorted));
    if (cached != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("cached", cached));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
        "application/json", "application/x-javascript; charset=UTF-8", "application/javascript; charset=UTF-8"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
        @Override
        public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
          com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
          return originalResponse.newBuilder()
              .body(new ProgressResponseBody(originalResponse.body(), progressListener))
              .build();
        }
      });
    }

    String[] localVarAuthNames = new String[]{"api_key"};
    return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call queryApiValidateBeforeCall(String q, String s, String g, String n, String e, String p, Boolean i, Boolean autoEvents, String summarization, Boolean listMode, Boolean strict, Boolean includeObsoleteMetrics, Boolean sorted, Boolean cached, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

    // verify the required parameter 'q' is set
    if (q == null) {
      throw new ApiException("Missing the required parameter 'q' when calling queryApi(Async)");
    }

    // verify the required parameter 's' is set
    if (s == null) {
      throw new ApiException("Missing the required parameter 's' when calling queryApi(Async)");
    }

    // verify the required parameter 'g' is set
    if (g == null) {
      throw new ApiException("Missing the required parameter 'g' when calling queryApi(Async)");
    }


    com.squareup.okhttp.Call call = queryApiCall(q, s, g, n, e, p, i, autoEvents, summarization, listMode, strict, includeObsoleteMetrics, sorted, cached, progressListener, progressRequestListener);
    return call;

  }

  /**
   * Perform a charting query against Wavefront servers that returns the appropriate points in the specified time window and granularity
   * Long time spans and small granularities can take a long time to calculate
   *
   * @param q                      the query expression to execute (required)
   * @param s                      the start time of the query window in epoch milliseconds (required)
   * @param g                      the granularity of the points returned (required)
   * @param n                      name used to identify the query (optional)
   * @param e                      the end time of the query window in epoch milliseconds (null to use now) (optional)
   * @param p                      the approximate maximum number of points to return (may not limit number of points exactly) (optional)
   * @param i                      whether series with only points that are outside of the query window will be returned (defaults to true) (optional)
   * @param autoEvents             whether events for sources included in the query will be automatically returned by the query (optional)
   * @param summarization          summarization strategy to use when bucketing points together (optional)
   * @param listMode               retrieve events more optimally displayed for a list (optional)
   * @param strict                 do not return points outside the query window [s;e), defaults to false (optional)
   * @param includeObsoleteMetrics include metrics that have not been reporting recently, defaults to false (optional)
   * @param sorted                 sorts the output so that returned series are in order, defaults to false (optional, default to false)
   * @param cached                 whether the query cache is used, defaults to true (optional, default to true)
   * @return QueryResult
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
   */
  public QueryResult queryApi(String q, String s, String g, String n, String e, String p, Boolean i, Boolean autoEvents, String summarization, Boolean listMode, Boolean strict, Boolean includeObsoleteMetrics, Boolean sorted, Boolean cached) throws ApiException {
    ApiResponse<QueryResult> resp = queryApiWithHttpInfo(q, s, g, n, e, p, i, autoEvents, summarization, listMode, strict, includeObsoleteMetrics, sorted, cached);
    return resp.getData();
  }

  /**
   * Perform a charting query against Wavefront servers that returns the appropriate points in the specified time window and granularity
   * Long time spans and small granularities can take a long time to calculate
   *
   * @param q                      the query expression to execute (required)
   * @param s                      the start time of the query window in epoch milliseconds (required)
   * @param g                      the granularity of the points returned (required)
   * @param n                      name used to identify the query (optional)
   * @param e                      the end time of the query window in epoch milliseconds (null to use now) (optional)
   * @param p                      the approximate maximum number of points to return (may not limit number of points exactly) (optional)
   * @param i                      whether series with only points that are outside of the query window will be returned (defaults to true) (optional)
   * @param autoEvents             whether events for sources included in the query will be automatically returned by the query (optional)
   * @param summarization          summarization strategy to use when bucketing points together (optional)
   * @param listMode               retrieve events more optimally displayed for a list (optional)
   * @param strict                 do not return points outside the query window [s;e), defaults to false (optional)
   * @param includeObsoleteMetrics include metrics that have not been reporting recently, defaults to false (optional)
   * @param sorted                 sorts the output so that returned series are in order, defaults to false (optional, default to false)
   * @param cached                 whether the query cache is used, defaults to true (optional, default to true)
   * @return ApiResponse&lt;QueryResult&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
   */
  public ApiResponse<QueryResult> queryApiWithHttpInfo(String q, String s, String g, String n, String e, String p, Boolean i, Boolean autoEvents, String summarization, Boolean listMode, Boolean strict, Boolean includeObsoleteMetrics, Boolean sorted, Boolean cached) throws ApiException {
    com.squareup.okhttp.Call call = queryApiValidateBeforeCall(q, s, g, n, e, p, i, autoEvents, summarization, listMode, strict, includeObsoleteMetrics, sorted, cached, null, null);
    Type localVarReturnType = new TypeToken<QueryResult>() {
    }.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Perform a charting query against Wavefront servers that returns the appropriate points in the specified time window and granularity (asynchronously)
   * Long time spans and small granularities can take a long time to calculate
   *
   * @param q                      the query expression to execute (required)
   * @param s                      the start time of the query window in epoch milliseconds (required)
   * @param g                      the granularity of the points returned (required)
   * @param n                      name used to identify the query (optional)
   * @param e                      the end time of the query window in epoch milliseconds (null to use now) (optional)
   * @param p                      the approximate maximum number of points to return (may not limit number of points exactly) (optional)
   * @param i                      whether series with only points that are outside of the query window will be returned (defaults to true) (optional)
   * @param autoEvents             whether events for sources included in the query will be automatically returned by the query (optional)
   * @param summarization          summarization strategy to use when bucketing points together (optional)
   * @param listMode               retrieve events more optimally displayed for a list (optional)
   * @param strict                 do not return points outside the query window [s;e), defaults to false (optional)
   * @param includeObsoleteMetrics include metrics that have not been reporting recently, defaults to false (optional)
   * @param sorted                 sorts the output so that returned series are in order, defaults to false (optional, default to false)
   * @param cached                 whether the query cache is used, defaults to true (optional, default to true)
   * @param callback               The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call queryApiAsync(String q, String s, String g, String n, String e, String p, Boolean i, Boolean autoEvents, String summarization, Boolean listMode, Boolean strict, Boolean includeObsoleteMetrics, Boolean sorted, Boolean cached, final ApiCallback<QueryResult> callback) throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener = new ProgressResponseBody.ProgressListener() {
        @Override
        public void update(long bytesRead, long contentLength, boolean done) {
          callback.onDownloadProgress(bytesRead, contentLength, done);
        }
      };

      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
        @Override
        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
          callback.onUploadProgress(bytesWritten, contentLength, done);
        }
      };
    }

    com.squareup.okhttp.Call call = queryApiValidateBeforeCall(q, s, g, n, e, p, i, autoEvents, summarization, listMode, strict, includeObsoleteMetrics, sorted, cached, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<QueryResult>() {
    }.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }

  /**
   * Build call for queryRaw
   *
   * @param metric                  metric to query ingested points for (cannot contain wildcards) (required)
   * @param host                    host to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param source                  source to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param startTime               start time in epoch milliseconds (cannot be more than a day in the past) null to use an hour before endTime (optional)
   * @param endTime                 end time in epoch milliseconds (cannot be more than a day in the past) null to use now (optional)
   * @param progressListener        Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public com.squareup.okhttp.Call queryRawCall(String metric, String host, String source, Long startTime, Long endTime, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/api/v2/chart/raw";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (host != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("host", host));
    if (source != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
    if (metric != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("metric", metric));
    if (startTime != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("startTime", startTime));
    if (endTime != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("endTime", endTime));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
        @Override
        public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
          com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
          return originalResponse.newBuilder()
              .body(new ProgressResponseBody(originalResponse.body(), progressListener))
              .build();
        }
      });
    }

    String[] localVarAuthNames = new String[]{"api_key"};
    return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private com.squareup.okhttp.Call queryRawValidateBeforeCall(String metric, String host, String source, Long startTime, Long endTime, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

    // verify the required parameter 'metric' is set
    if (metric == null) {
      throw new ApiException("Missing the required parameter 'metric' when calling queryRaw(Async)");
    }


    com.squareup.okhttp.Call call = queryRawCall(metric, host, source, startTime, endTime, progressListener, progressRequestListener);
    return call;

  }

  /**
   * Perform a raw data query against Wavefront servers that returns second granularity points grouped by tags
   * An API to check if ingested points are as expected.  Points ingested within a single second are averaged when returned.
   *
   * @param metric    metric to query ingested points for (cannot contain wildcards) (required)
   * @param host      host to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param source    source to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param startTime start time in epoch milliseconds (cannot be more than a day in the past) null to use an hour before endTime (optional)
   * @param endTime   end time in epoch milliseconds (cannot be more than a day in the past) null to use now (optional)
   * @return List&lt;RawTimeseries&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
   */
  public List<RawTimeseries> queryRaw(String metric, String host, String source, Long startTime, Long endTime) throws ApiException {
    ApiResponse<List<RawTimeseries>> resp = queryRawWithHttpInfo(metric, host, source, startTime, endTime);
    return resp.getData();
  }

  /**
   * Perform a raw data query against Wavefront servers that returns second granularity points grouped by tags
   * An API to check if ingested points are as expected.  Points ingested within a single second are averaged when returned.
   *
   * @param metric    metric to query ingested points for (cannot contain wildcards) (required)
   * @param host      host to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param source    source to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param startTime start time in epoch milliseconds (cannot be more than a day in the past) null to use an hour before endTime (optional)
   * @param endTime   end time in epoch milliseconds (cannot be more than a day in the past) null to use now (optional)
   * @return ApiResponse&lt;List&lt;RawTimeseries&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
   */
  public ApiResponse<List<RawTimeseries>> queryRawWithHttpInfo(String metric, String host, String source, Long startTime, Long endTime) throws ApiException {
    com.squareup.okhttp.Call call = queryRawValidateBeforeCall(metric, host, source, startTime, endTime, null, null);
    Type localVarReturnType = new TypeToken<List<RawTimeseries>>() {
    }.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * Perform a raw data query against Wavefront servers that returns second granularity points grouped by tags (asynchronously)
   * An API to check if ingested points are as expected.  Points ingested within a single second are averaged when returned.
   *
   * @param metric    metric to query ingested points for (cannot contain wildcards) (required)
   * @param host      host to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param source    source to query ingested points for (cannot contain wildcards). host or source is equivalent, only one should be used. (optional)
   * @param startTime start time in epoch milliseconds (cannot be more than a day in the past) null to use an hour before endTime (optional)
   * @param endTime   end time in epoch milliseconds (cannot be more than a day in the past) null to use now (optional)
   * @param callback  The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public com.squareup.okhttp.Call queryRawAsync(String metric, String host, String source, Long startTime, Long endTime, final ApiCallback<List<RawTimeseries>> callback) throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener = new ProgressResponseBody.ProgressListener() {
        @Override
        public void update(long bytesRead, long contentLength, boolean done) {
          callback.onDownloadProgress(bytesRead, contentLength, done);
        }
      };

      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
        @Override
        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
          callback.onUploadProgress(bytesWritten, contentLength, done);
        }
      };
    }

    com.squareup.okhttp.Call call = queryRawValidateBeforeCall(metric, host, source, startTime, endTime, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<List<RawTimeseries>>() {
    }.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
}
